<pou name="VFD" pouType="functionBlock">
    <interface>
        <inOutVars>
            <variable name="MTPBase"><type><derived name="FB_MTP_MonAnaDrv" /></type></variable>
        </inOutVars>
        <inputVars>
            <variable name="id"><type><INT /></type></variable>
            <variable name="forward"><type><BOOL /></type></variable>
            <variable name="reverse"><type><BOOL /></type></variable>
            <variable name="speed"><type><REAL /></type></variable>
            <variable name="speedUnit"><type><INT /></type></variable>
            <variable name="speedMin"><type><REAL /></type></variable>
            <variable name="speedMax"><type><REAL /></type></variable>
            <variable name="forwardFeedback"><type><BOOL /></type></variable>
            <variable name="reverseFeedback"><type><BOOL /></type></variable>
            <variable name="speedFeedback"><type><WORD /></type></variable>
            <variable name="speedScaleMin"><type><REAL /></type></variable>
            <variable name="speedScaleMax"><type><REAL /></type></variable>
            <variable name="hasFwdFeedback"><type><BOOL /></type></variable>
            <variable name="hasRevFeedback"><type><BOOL /></type></variable>
            <variable name="enableForward"><type><BOOL /></type></variable>
            <variable name="enableReverse"><type><BOOL /></type></variable>
            <variable name="trip"><type><BOOL /></type></variable>
            <variable name="safeHold"><type><BOOL /></type></variable>
            <variable name="monitor"><type><BOOL /></type></variable>
            <variable name="staticTimeout"><type><REAL /></type></variable>
            <variable name="dynamicTimeout"><type><REAL /></type></variable>
            <variable name="simulate"><type><BOOL /></type></variable>
            <variable name="simulateDelay"><type><REAL /></type></variable>
            <variable name="interlockIn"><type><BOOL /></type></variable>
            <variable name="permitIn"><type><BOOL /></type></variable>
            <variable name="protectIn"><type><BOOL /></type></variable>
            <variable name="reset"><type><BOOL /></type></variable>
        </inputVars>
        <outputVars>
            <variable name="fwdCommand"><type><BOOL /></type></variable>
            <variable name="revCommand"><type><BOOL /></type></variable>
            <variable name="forwardActive"><type><BOOL /></type></variable>
            <variable name="reverseActive"><type><BOOL /></type></variable>
            <variable name="actualSpeed"><type><REAL /></type></variable>
            <variable name="remote"><type><BOOL /></type></variable>
            <variable name="operatorMode"><type><BOOL /></type></variable>
            <variable name="automaticMode"><type><BOOL /></type></variable>
            <variable name="offlineMode"><type><BOOL /></type></variable>
            <variable name="remoteSource"><type><BOOL /></type></variable>
            <variable name="internalSourceAct"><type><BOOL /></type></variable>
            <variable name="manualSourceAct"><type><BOOL /></type></variable>
        </outputVars>
        <localVars>
            <variable name="first_scan"><type><BOOL /></type><initialValue><simpleValue value="TRUE" /></initialValue></variable>
            <variable name="second_scan"><type><BOOL /></type></variable>
            <variable name="fwdFbkSimulated"><type><BOOL /></type></variable>
            <variable name="revFbkSimulated"><type><BOOL /></type></variable>
            <variable name="DelayTimer1"><type><derived name="TON" /></type></variable>
            <variable name="DelayTimer2"><type><derived name="TON" /></type></variable><!-- Temporary variables for MTP base interface access -->
            <variable name="StateChannel"><type><BOOL /></type></variable>
            <variable name="StateOpAct"><type><BOOL /></type></variable>
            <variable name="StateAutAct"><type><BOOL /></type></variable>
            <variable name="StateOffAct"><type><BOOL /></type></variable>
            <variable name="SrcChannel"><type><BOOL /></type></variable>
            <variable name="SrcIntAct"><type><BOOL /></type></variable>
            <variable name="SrcManAct"><type><BOOL /></type></variable>
            <variable name="PermEn"><type><BOOL /></type></variable>
            <variable name="Permit"><type><BOOL /></type></variable>
            <variable name="IntlEn"><type><BOOL /></type></variable>
            <variable name="Interlock"><type><BOOL /></type></variable>
            <variable name="ProtEn"><type><BOOL /></type></variable>
            <variable name="Protect"><type><BOOL /></type></variable>
            <variable name="WQC"><type><BYTE /></type></variable>
            <variable name="OSLevel"><type><BYTE /></type></variable>
            <variable name="SafePos"><type><BOOL /></type></variable>
            <variable name="FwdAut"><type><BOOL /></type></variable>
            <variable name="RevAut"><type><BOOL /></type></variable>
            <variable name="FwdCtrl"><type><BOOL /></type></variable>
            <variable name="RevCtrl"><type><BOOL /></type></variable>
            <variable name="RpmSclMin"><type><REAL /></type></variable>
            <variable name="RpmSclMax"><type><REAL /></type></variable>
            <variable name="RpmUnit"><type><INT /></type></variable>
            <variable name="RpmMin"><type><REAL /></type></variable>
            <variable name="RpmMax"><type><REAL /></type></variable>
            <variable name="RpmRbk"><type><REAL /></type></variable>
            <variable name="Rpm"><type><REAL /></type></variable>
            <variable name="RevFbkCalc"><type><BOOL /></type></variable>
            <variable name="RevFbk"><type><BOOL /></type></variable>
            <variable name="FwdFbkCalc"><type><BOOL /></type></variable>
            <variable name="FwdFbk"><type><BOOL /></type></variable>
            <variable name="Trip"><type><BOOL /></type></variable>
            <variable name="ResetAut"><type><BOOL /></type></variable>
            <variable name="MonSafePos"><type><BOOL /></type></variable>
            <variable name="MonStatTi"><type><REAL /></type></variable>
            <variable name="MonDynTi"><type><REAL /></type></variable>
            <!-- Helper variables for sync detection -->
        </localVars>
    </interface>
    <body>
        <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">
                <![CDATA[

// STARTUP - SECOND SCAN
IF second_scan THEN
    // switch control mode back to operator
    MTPBase.StateChannel := FALSE;
    // reset command to switch to auto mode
    MTPBASE.StateAutAut := FALSE;    
    // end second scan
    second_scan := FALSE;
END_IF;

// STARTUP - FIRST SCAN
IF first_scan THEN
    // allow program control for the mode
    MTPBase.StateChannel := TRUE;
    // switch to auto mode
    MTPBASE.StateAutAut := TRUE;
    // send a reset (will be reset automatically) (TODO: why is this needed?)
    reset := TRUE;
    // prepare second scan
    first_scan := FALSE;
    second_scan := TRUE;
END_IF;

// sync variables with MTPBase
// - a variable on MTPBase that can be changed from the HMI
// - an input on the wrapper block
// how: store the variable from the MTPBase on a helper variable, and then compare each cycle if the operator has changed it
// if yes then copy it to the input on the wrapper block
// if not then copy the wrapper block input to the MTPBase variable

// copy from and to the MTPBase
// there is no need to execute the MTPBase block here because it gets executed as part of the auto-generated MTP code
    MTPBase.PermEn := PermEn;
    MTPBase.Permit := Permit;
    MTPBase.IntlEn := IntlEn;
    MTPBase.Interlock := Interlock;
    MTPBase.ProtEn := ProtEn;
    MTPBase.Protect := Protect;
    MTPBase.WQC := WQC;
    MTPBase.OSLevel := OSLevel;
    MTPBase.SafePos := SafePos;
    MTPBase.FwdAut := FwdAut;
    MTPBase.RevAut := RevAut;
    MTPBase.RpmSclMin := RpmSclMin;
    MTPBase.RpmSclMax := RpmSclMax;
    MTPBase.RpmUnit := RpmUnit;
    MTPBase.RpmMin := RpmMin;
    MTPBase.RpmMax := RpmMax;
    MTPBase.RpmRbk := RpmRbk;
    MTPBase.RevFbkCalc := RevFbkCalc;
    MTPBase.RevFbk := RevFbk;
    MTPBase.FwdFbkCalc := FwdFbkCalc;
    MTPBase.FwdFbk := FwdFbk;
    MTPBase.Trip := Trip;
    MTPBase.ResetAut := ResetAut;
    MTPBase.MonSafePos := MonSafePos;
    MTPBase.MonStatTi := MonStatTi;
    MTPBase.MonDynTi := MonDynTi;
    StateChannel := MTPBase.StateChannel;
    StateOpAct := MTPBase.StateOpAct;
    StateAutAct := MTPBase.StateAutAct;
    StateOffAct := MTPBase.StateOffAct;
    SrcChannel := MTPBase.SrcChannel;
    SrcIntAct := MTPBase.SrcIntAct;
    SrcManAct := MTPBase.SrcManAct;
    FwdCtrl := MTPBase.FwdCtrl;
    RevCtrl := MTPBase.RevCtrl;
    Rpm := MTPBase.Rpm;
    RevFbkCalc := MTPBase.RevFbkCalc;
    FwdFbkCalc := MTPBase.FwdFbkCalc;



// Functionality

WQC := 16#FF;
OSLevel := 16#00;
remote := StateChannel;
operatorMode := StateOpAct;
automaticMode := StateAutAct;
offlineMode := StateOffAct;
remoteSource := SrcChannel;
internalSourceAct := SrcIntAct;
manualSourceAct := SrcManAct;
PermEn := True;
IntlEn := True;
ProtEn := True;
Permit := permitIn;
Interlock := NOT interlockIn;
Protect := NOT protectIn;
SafePos := False;
FwdAut := forward;
RevAut := reverse;
fwdCommand := FwdCtrl;
revCommand := RevCtrl;
FwdFbkCalc := simulate OR NOT hasFwdFeedback;
RevFbkCalc := simulate OR NOT hasRevFeedback;
DelayTimer1(IN:= (simulate OR NOT hasFwdFeedback) AND fwdCommand, PT:= REAL_TO_TIME(simulateDelay * 1000));
fwdFbkSimulated := DelayTimer1.Q;
DelayTimer2(IN:= (simulate OR NOT hasRevFeedback) AND NOT revCommand, PT:= REAL_TO_TIME(simulateDelay * 1000));
revFbkSimulated := DelayTimer2.Q;
FwdFbk := (forwardFeedback AND NOT FwdFbkCalc) OR (fwdFbkSimulated AND FwdFbkCalc);
RevFbk := (reverseFeedback AND NOT RevFbkCalc) OR (revFbkSimulated AND RevFbkCalc);
Trip := trip;
ResetAut := reset;
RpmSclMin := speedMin;
RpmSclMax := speedMax;
RpmUnit := speedUnit;
RpmMin := speedMin;
RpmMax := speedMax;
RpmRbk := speedFeedback;
actualSpeed := Rpm;
reset := False;
MonSafePos := safeHold;
MonStatTi := staticTimeout;
MonDynTi := dynamicTimeout;

                ]]>
            </xhtml>
        </ST>
    </body>
    <addData>
        <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="FB_INIT" ObjectId="8568aabb-efd1-4e11-b093-9ebdb5b0ac2b">
                <interface>
                    <returnType><BOOL /></returnType>
                    <inputVars>
                        <variable name="bInitRetains">
                            <type><BOOL /></type>
                            <documentation><xhtml xmlns="http://www.w3.org/1999/xhtml"> TRUE: the retain variables are initialized (reset warm / reset cold)</xhtml></documentation>
                        </variable>
                        <variable name="bInCopyCode">
                            <type><BOOL /></type>
                            <documentation><xhtml xmlns="http://www.w3.org/1999/xhtml"> TRUE: the instance will be copied to the copy code afterward (online change)   </xhtml></documentation>
                        </variable>
                    </inputVars>
                    <documentation>
                        <xhtml xmlns="http://www.w3.org/1999/xhtml">
FB_Init is always available implicitly and it is used primarily for initialization.
                        </xhtml>
                    </documentation>
                </interface>
                <body>
                    <ST>
                        <xhtml xmlns="http://www.w3.org/1999/xhtml">
// assign default values on initialization
THIS^.speedMin := 0;
THIS^.speedMax := 100;
THIS^.hasFwdFeedback := True;
THIS^.hasRevFeedback := True;
THIS^.trip := True;
THIS^.monitor := True;
THIS^.staticTimeout := 2;
THIS^.dynamicTimeout := 5;
THIS^.simulateDelay := 1;
THIS^.permitIn := 1;


                        </xhtml>
                    </ST>
                </body>
            </Method>
        </data>
    </addData>
</pou>