{#- Template functions - these will be handled in the context -#}
{#- Set output file name -#}
{#- The file will be named {{ Name }}.xml -#}
<pou name="{{ Name }}" pouType="functionBlock">
    <interface>
        <inOutVars>
{%- for variable in inoutVars %}
            <variable name="{{ variable.name }}"><type>{%- if variable.isDerived %}<derived name="FB_MTP_{{ variable['Data Type'] }}" />{%- else %}<{{ variable['Data Type'] | upper }} />{%- endif %}</type></variable>
{%- endfor %}
        </inOutVars>
        <inputVars>
{%- for variable in inputVars %}
    {%- if variable.name not in ['alarmHigh', 'warningHigh', 'toleranceHigh', 'toleranceLow', 'warningLow', 'alarmLow'] %}
            <variable name="{{ variable.name }}"><type>{%- if variable.isDerived %}<derived name="{{ variable['Data Type'] }}" />{%- else %}<{{ variable['Data Type'] | upper }} />{%- endif %}</type></variable>
    {%- endif %}
{%- endfor %}
        </inputVars>
        <outputVars>
{%- for variable in outputVars %}
            <variable name="{{ variable.name }}"><type>{%- if variable.isDerived %}<derived name="{{ variable['Data Type'] }}" />{%- else %}<{{ variable['Data Type'] | upper }} />{%- endif %}</type></variable>
{%- endfor %}
        </outputVars>
        <localVars>
            <variable name="first_scan"><type><BOOL /></type><initialValue><simpleValue value="TRUE" /></initialValue></variable>
            <variable name="second_scan"><type><BOOL /></type></variable>
{%- for variable in localVars %}
            <variable name="{{ variable.name }}"><type>{%- if variable.isDerived %}<derived name="{{ variable['Data Type'] }}" />{%- else %}<{{ variable['Data Type'] | upper }} />{%- endif %}</type></variable>
{%- endfor -%}
{%- if DelayTimerCount > 0 -%}
    {%- for i in range(1, DelayTimerCount + 1) %}
            <variable name="DelayTimer{{ i }}"><type><derived name="TON" /></type></variable>
    {%- endfor -%}
{%- endif -%}
            <!-- Temporary variables for MTP base interface access -->
{%- for variable in mtpBaseVarsUsed %}
            <variable name="{{ variable.name }}"><type>{%- if variable.isDerived %}<derived name="{{ variable['Data Type'] }}" />{%- else %}<{{ variable['Data Type'] | upper }} />{%- endif %}</type></variable>
{%- endfor %}
            <!-- Helper variables for sync detection -->
{%- for sync in syncs %}
    {%- if sync.name not in ['alarmHigh', 'warningHigh', 'toleranceHigh', 'toleranceLow', 'warningLow', 'alarmLow'] %}
            <variable name="{{ sync.SyncVariable }}Last"><type>{%- if Variables[sync.name] and Variables[sync.name].isDerived %}<derived name="{{ Variables[sync.name]['Data Type'] }}" />{%- elif Variables[sync.name] %}<{{ Variables[sync.name]['Data Type'] | upper }} />{%- elif MTPBaseVariables[sync.SyncVariable] and MTPBaseVariables[sync.SyncVariable].isDerived %}<derived name="{{ MTPBaseVariables[sync.SyncVariable]['Data Type'] }}" />{%- elif MTPBaseVariables[sync.SyncVariable] %}<{{ MTPBaseVariables[sync.SyncVariable]['Data Type'] | upper }} />{%- else %}<TYPENOTFOUND />{%- endif %}</type></variable>
    {%- endif %}
{%- endfor %}
        </localVars>
    </interface>
    <body>
        <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml">
                <![CDATA[

// STARTUP - SECOND SCAN
IF second_scan THEN
    {%- if Name in ['AnalogValve', 'ReversingMotor', 'SolenoidValve', 'VFD'] %}
    // switch control mode back to operator
    MTPBase.StateChannel := FALSE;
    // reset command to switch to auto mode
    MTPBASE.StateAutAut := FALSE;
    {%- endif %}    
    // end second scan
    second_scan := FALSE;
END_IF;

// STARTUP - FIRST SCAN
IF first_scan THEN
    {%- if Name in ['AnalogValve', 'ReversingMotor', 'SolenoidValve', 'VFD'] %}
    // allow program control for the mode
    MTPBase.StateChannel := TRUE;
    // switch to auto mode
    MTPBASE.StateAutAut := TRUE;
    // send a reset (will be reset automatically) (TODO: why is this needed?)
    reset := TRUE;
    {%- endif %}
    // prepare second scan
    first_scan := FALSE;
    second_scan := TRUE;
END_IF;

// sync variables with MTPBase
// - a variable on MTPBase that can be changed from the HMI
// - an input on the wrapper block
// how: store the variable from the MTPBase on a helper variable, and then compare each cycle if the operator has changed it
// if yes then copy it to the input on the wrapper block
// if not then copy the wrapper block input to the MTPBase variable
{%- for sync in syncs %}
{%- if sync.name not in ['alarmHigh', 'warningHigh', 'toleranceHigh', 'toleranceLow', 'warningLow', 'alarmLow'] %}

// Sync {{ sync.name }} with MTPBase.{{ sync.SyncVariable }}
IF {{ sync.SyncVariable }}Last <> MTPBase.{{ sync.SyncVariable }} THEN
    // MTPBase variable changed (from HMI) - copy to wrapper input
    {{ sync.name }} := MTPBase.{{ sync.SyncVariable }};
ELSE
    // MTPBase not changed - always copy wrapper input to MTPBase
    MTPBase.{{ sync.SyncVariable }} := {{ sync.name }};
END_IF;
{{ sync.SyncVariable }}Last := MTPBase.{{ sync.SyncVariable }};
{%- endif %}
{%- endfor %}

// copy from and to the MTPBase
// there is no need to execute the MTPBase block here because it gets executed as part of the auto-generated MTP code
{%- for variable in mtpBaseVarsWrite %}
    MTPBase.{{ variable.name }} := {{ variable.name }};
{%- endfor %}

{%- for variable in mtpBaseVarsRead %}
    {{ variable.name }} := MTPBase.{{ variable.name }};
{%- endfor %}



// Functionality
{% for func in allFunctionality -%}
    {#-###### EXPLANATION ######-#}
    {%- if func.logicType == 'Explanation' %}
// {{ func.comment }}
    {#-###### EXPRESSION ######-#}
    {%- elif func.logicType == 'Expression' -%}    
        {#-###### EXPRESSION WITH DELAY ######-#}         
        {%- if func.delayTimerNumber %}
DelayTimer{{ func.delayTimerNumber }}(IN:= {{ func.expression }}, PT:= INT_TO_TIME(REAL_TO_INT({{ func.delayVariable }} * 1000)));
{{ func.key }} := DelayTimer{{ func.delayTimerNumber }}.Q;
        {#-###### EXPRESSION WITHOUT DELAY ######-#}  
        {%- else %}
{{ func.key }} := {{ func.expression }};
        {%- endif -%}
    {#-###### SET ######-#}
    {%- elif func.logicType == 'Set' %}
        {#- Handle SET with optional delay -#}
        {%- if func.setDelayTimerNumber %}
DelayTimer{{ func.setDelayTimerNumber }}(IN:= {{ func.set | safe }}, PT:= INT_TO_TIME(REAL_TO_INT({{ func.setDelayVariable }} * 1000)));
        {%- endif %}
        {#- Generate the actual Set logic #}
IF {% if func.setDelayTimerNumber %}DelayTimer{{ func.setDelayTimerNumber }}.Q{% else %}{{ func.set | safe }}{% endif %} THEN
    {{ func.key | replace('_Set', '') }} := TRUE;
END_IF;
    {#-###### RESET ######-#}
    {%- elif func.logicType == 'Reset' %}
        {#- Handle RESET with optional delay -#}
        {%- if func.resetDelayTimerNumber %}
DelayTimer{{ func.resetDelayTimerNumber }}(IN:= {{ func.reset | safe }}, PT:= INT_TO_TIME(REAL_TO_INT({{ func.resetDelayVariable }} * 1000)));
        {%- endif %}
        {#- Generate the actual Reset logic #}
IF {% if func.resetDelayTimerNumber %}DelayTimer{{ func.resetDelayTimerNumber }}.Q{% else %}{{ func.reset | safe }}{% endif %} THEN
    {{ func.key | replace('_Reset', '') }} := FALSE;
END_IF;
    {#-###### STATE MACHINE ######-#}
    {%- elif func.logicType == 'StateMachine' %}
        {#- Generate state machine delay timers first -#}
        {%- for stateName, stateData in func.stateMachine %}
            {%- for targetState, transitionData in stateData.Transitions %}
                {%- if transitionData.DelayTimerNumber %}
DelayTimer{{ transitionData.DelayTimerNumber }}(IN:= {{ transitionData.Condition | safe }}, PT:= INT_TO_TIME(REAL_TO_INT({{ transitionData.DelayVariable }} * 1000)));
                {%- endif %}
            {%- endfor %}
        {%- endfor %}
        {#- Generate state machine CASE statement #}
CASE {{ func.key }} OF
        {%- for stateName, stateData in func.stateMachine %}
    {{ stateName }}: // {{ stateData.Name }}
            {%- for targetState, transitionData in stateData.Transitions %}
        IF {% if transitionData.DelayTimerNumber %}DelayTimer{{ transitionData.DelayTimerNumber }}.Q{% else %}{{ transitionData.Condition | safe }}{% endif %} THEN
            {{ func.key }} := {{ targetState }};
        END_IF;
            {%- endfor %}
        {%- endfor %}
END_CASE;
    {#-###### BLANK LINE ######-#}
    {%- elif func.logicType == 'BlankLine' %}
    {% endif -%}
{%- endfor %}

                ]]>
            </xhtml>
        </ST>
    </body>
    <addData>
        <data name="http://www.3s-software.com/plcopenxml/method" handleUnknown="implementation">
            <Method name="FB_INIT" ObjectId="8568aabb-efd1-4e11-b093-9ebdb5b0ac2b">
                <interface>
                    <returnType><BOOL /></returnType>
                    <inputVars>
                        <variable name="bInitRetains">
                            <type><BOOL /></type>
                            <documentation><xhtml xmlns="http://www.w3.org/1999/xhtml"> TRUE: the retain variables are initialized (reset warm / reset cold)</xhtml></documentation>
                        </variable>
                        <variable name="bInCopyCode">
                            <type><BOOL /></type>
                            <documentation><xhtml xmlns="http://www.w3.org/1999/xhtml"> TRUE: the instance will be copied to the copy code afterward (online change)   </xhtml></documentation>
                        </variable>
                    </inputVars>
                    <documentation>
                        <xhtml xmlns="http://www.w3.org/1999/xhtml">
FB_Init is always available implicitly and it is used primarily for initialization.
                        </xhtml>
                    </documentation>
                </interface>
                <body>
                    <ST>
                        <xhtml xmlns="http://www.w3.org/1999/xhtml">
// assign default values on initialization
{%- for variable in inputVars %}
    {%- if variable.name not in ['alarmHigh', 'warningHigh', 'toleranceHigh', 'toleranceLow', 'warningLow', 'alarmLow'] and variable.Default and variable.Default != "" %}
THIS^.{{ variable.name }} := {{ variable.Default }};
    {%- endif %}
{%- endfor %}
{%- for variable in outputVars %}
    {%- if variable.Default and variable.Default != "" %}
THIS^.{{ variable.name }} := {{ variable.Default }};
    {%- endif %}
{%- endfor %}
{%- for variable in localVars %}
    {%- if variable.Default and variable.Default != "" %}
THIS^.{{ variable.name }} := {{ variable.Default }};
    {%- endif %}
{%- endfor %}


                        </xhtml>
                    </ST>
                </body>
            </Method>
        </data>
    </addData>
</pou>